2.1-1
A = 31, 41, 59, 26, 41, 58
J = 2
key = 41
i = 1

	31 > 41 false
A[2] = 41 
A = 31, 41, 59, 26, 41, 58

J = 3
key = 59
i = 2
	41 > 59 false
A[2] = 59
A = 31, 41, 59, 26, 41, 58

J = 4
key = 26
i = 3
	59 > 26 true
	A[4] = A[3]
	A = 31, 41, 59, 59, 41, 58

i = 2
	41 > 26 true
	A[3] = A[2]
	A = 31, 41, 41, 59, 41, 58

i = 1
	31 > 26 true
	A[2] = A[1]
	A = 31, 31, 41, 59, 41, 58

i = 0
	i > 0 false
A[1] = 26
A = 26, 31, 41, 59, 41, 58

J = 5
key = 41
i = 4
	59 > 41 true
	A[5] = A[4]
	A = 26, 31, 41, 59, 59, 58

i = 3
	41 > 41 false
A[4] = 41
A = 26, 31, 41, 41, 59, 58

J = 6
key 58
i = 5
	59 > 58 true
	A[6] = A[5]
	A = 26, 31, 41, 41, 58, 59

i = 4
	41 > 59 false

A[5] = 58
J = 7

J > A.length
end

2.1-2
sort(A)
for j = 2 to A.length
	key = A[j]
	i = j -1

	while i > 0 and A[i] < key
		A[i+1] = A[i]
		i = i - 1
	A[i+1] = key

2.1-3
search(i, A)
	v = nil
	foreach a in A
		if (a == i)
			v = a
			break

return v

Loop invariant: If i exists in A then v = A[i] else i = nil
Initialisation: i = nil
Maintenance: The loop will only iterate while i = nil
Termination: If i is not assigned a value it is still nil which is ok.

2.1-4
Input: Two n-element arrays such that eash element contains either 0 or 1 
and each array as a whole represents a binary number of n bits.

Output: An n + 1 element array C representing th sum of A + B


2.2-1
O(n^3)

2.2-2
section-sort(A)

	for i = 1 to A.length - 1
		min = i
		for j = i to A.length
			if A[j] < A[min]
				min = j
		swap A[min], A[i]

loop invariant: Everything smaller than i is sorted.

It runs for n-1 iterations because when i = n, everything before i is sorted and n
is sorted by virtue of being a single element array.

O(n^2)

2.2-3
On average a linear search will iterate through half the elemetns if the element
being searched for is equally likely to be any element in the array.

O(n) for bpth cases because we do not concern ourselves with constants in O-notation.

(n) for bpth cases because we do not concern ourselves with constants in O-notation.(n) for bpth cases because we do not concern ourselves with constants in O-notation.

2.3-1
       |03 09 26 38 41 49 52 57|
  |03 26 41 52|        |09 38 49 57|
 |03 41|   |26 52|   |38 57|   |09 49|
|03| |41| |52| |26| |38| |57| |09| |49|

2.3-2
merge(A, p, q, r)
n1 = 1 - p + 1
n2 = r - q
let L[n1], R[n2]

for i = 1 to n1
	L[i] = A[p+i-1]
for j = 1 to n2
	R[j] = A[q+j]
L[n1+1] = inf
R[n2+1] = inf
i = 1
j = 1

for k = p to r
	if i > n1
		goto moveleft
	if j > n2
		goto moveright
	if L[i] <= R[j]
		goto moveleft
	else	
		goto moveright
	
	moveleft:
		A[k] = L[i]
		++i
		continue
	moveright:
		A[k] = R[j]
		++j
		continue

2.4.3
	T(n) = 2T(n/2) + n
	n = 2^k+1

T(2^k+1) = 2T(2^k+1 / 2) + 2^k+1
	= 2T(2^k) + "^k+1
	= 2(2^k lg 2^k) + 2^k+1
	= 2^k+1 ((lg2^k) + 1)
	= 2^k+1 lg 2^k+1

2.4-4
	T(n) = O(1) if n = 1 
	T(n) = T(n-1) + O(n)

2.4-5

int binary_search(A, l, r, s)
	
	int pivot = (l+r)/2

	if A[pivot] == s
		return pivot
	if r-l == 1
		return -1

	if s > A[pivot]
		return binary_search(A, pivot, r, s)
	else
		return binary_search(A, l, pivot, s)

To go from the base case og r-l == 1, return item not found, backwards until we reach the full starting array, we need to double the pivot until we reach the original input length. This takes 2^k =n where k = log2,n

2.3-6
The runtime of binary search is log(n) and it must be performed n times therefor nlogn. However there are still the swapping operations to consider. IN the worst case as input sorted backwards n swaps must be performed. Therefor the worst case runtime is still n^2
